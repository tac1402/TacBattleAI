---
title: SaveManager0
---

Это абстрактный класс от оторого вам нужно наследовать свою реализацию [SaveManager](../../TacSave/SaveManager). Он реализует базовое управление сохранениями, которое вы должны расширить и настроить для своего проекта.

## InEditor
_bool InEditor = false_

Запись происходит в отладочном режиме в редакторе Юнити (=true) или в откомпилированной игре (=false, по умолчанию). Во время отладки лучше переключить на =true, тогда сохранения будут записываться в Assets\SaveTmp (создайте соответствующую директорию), иначе они будут сохраняться исходя из настроек компьютера Application.persistentDataPath, что менее удобно во время отладки.

## IsDebugMode
_bool IsDebugMode = true_

Режим отладки, по умолчанию включен. Система сохарнение DirectConvert будет вести лог загрузки (_LoadLog.txt_) в корне игры (на дирректорию выше ../Assets).

## version
_string version = "v0.01"_

Если изменяется набор данных которые вы сохраняете увеличивайте номер версии, чтобы следить за совместимостью версий.

## LoadError
_event Change LoadError_

Подписка на событие позволяет отловить момент, когда во время загрузки игры произошла непредвиденная ошибка. [SaveCatalog](../../TacSave/SaveCatalog) обрабатывает это событие по умолчанию в UI загрузки.

## ILoadGet()
_virtual ILoadManager ILoadGet()_

Обязателен для переопределения в наследнике, чтобы предоставить интерфейс [ILoadManager](../../TacSave/ILoadManager). Подробности см. в [SaveManager](../../TacSave/SaveManager).

## SaveBin
_virtual void SaveBin(string argDirName, string argFileName)_

Переопределяется в наследнике, чтобы управлять ходом сохранения. Подробности см. в [SaveManager](../../TacSave/SaveManager).

## LoadBin
_virtual void LoadBin(string argDirName, string argFileName)_

Переопределяется в наследнике, чтобы управлять ходом загрузки. Подробности см. в [SaveManager](../../TacSave/SaveManager).

## LogicBound
_LogicBound<T>(List<T> allItem) where T : Item_

Вызывайте из наследника [SaveManager](../../TacSave/SaveManager). Указывает, что список объектов определенного типа является _привязанным только к логике_, а не к сцене. Это означает, что во время _ILoadManager.ResetGame()_ прошлый геймобъекты будут полность удалены со сцены, а содержащиеся в файле сохранений будут восстановлены из префаба. В качестве списка allItem ожидается созданный определенного типа список объектов, наследников от [Item](../../TacStandartU/Item), но с пустым/нулевым количеством объектов. Они будут воссозданы из сохранения в этот список. Ощистите этот список после загрузки, сами объекты останутся на сцене, а загружаемые объекты, которые ссылались на них восстановят эту ссылку.

## SceneBound
_SceneBound<T>(List<T> allItem) where T : Item_

Вызывайте из наследника [SaveManager](../../TacSave/SaveManager). Указывает, что список объектов определенного типа является _привязанным к сцене_. Это означает, что количество и идентификация объектов из этого списка не будет меняться от игре к игре, могут меняться только их свойства, которые будут загружены из сохранения, а самы геймобъекты пересозданы не будут. В качестве списка allItem ожидается созданный определенного типа список объектов, наследников от [Item](../../TacStandartU/Item), обязательно не с пустым списком. Вы должны гарантировать, что элементы из этого списка не находятся в уровнях игры (см. [EntityType](../../TacStandartU/EntityType)), а значит не будет удален при загрузке между прошлой и текущей игрой. На объекты из этого списка, можно будет по прежнему ссылаться из других объектов, ссылки на которые будут восстановленны при загрузке.

## RegObject
_RegObject(string argObjectId, GameObject argObject)_

Зарегистрировать объект argObject с уникальным текстовым идентификатором argObjectId. В схеме сохранения будет выделен специальный численный идентификатор и связан с текстовым идентификатором - ключом. Может использоваться для динамически возникающих объектов, производных от стабильного объекта. Например, пуля процесс постройки одного из отсеков здания. Тогда, можно организовать осмысленный идентификатор, по которому сразу понять к кому относится численный идентификатор. Например, 1021-b1 - может означать процесс постройки первого отсека здания 1021. Во время восстановления поведения игры эта информация поможет правильно восстановить подписки на события между этими объектами. Например, переподписаться на событие _окончания постройки_, чтобы главный объект - здание знал когда завершить анимацию. 

