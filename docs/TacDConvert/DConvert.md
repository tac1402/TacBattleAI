---
title: DConvert
---

Прежде, чем правильно настроить сохранение в игре и понять почему это сложный процесс, нужно понять почему не сработает просто сериализовать сцену Юнити? И в принципе почему сериализация это плохое решение.

## Почему не сработает просто сериализовать сцену?

На первый взгляд, идея сохранить игру выглядит просто: взять все игровые объекты (gameobject) на сцене, записать их в файл и потом восстановить. К сожалению, этот подход фундаментально несовместим с архитектурой Unity и требованиями реальных проектов. Попытка его реализовать приведёт не к упрощению, а к поломке системы сохранений.

### Вы сохраняете не состояние игры, а её «труп»
_Вместо этого нужно научится восстанавливать gameobject из префаба!_

Когда вы сериализуете GameObject, вы фиксируете его текущее техническое представление в движке: координаты Transform, ссылки на компоненты, настройки MeshRenderer и BoxCollider. Подавляющие большинство этих данных - это статический декор, т.е. статические или технические (коллайдеры, рендереры). Поэтому сериализовать их все — это гигабайты ненужных данных и минуты загрузки. Вместо этого нужно сохранять только состояние игры. Например, агент — это не его модель и коллайдер, а его имя, профессия, текущая цель и список задач. Восстанавливая только нужные для логики поведения данные мы экономим

### Ссылки превратятся в «битые» указатели
_Вместо этого нужно проиндексировать все объекты и после этого их связать по индексам_

В коде объекты ссылаются друг на друга: здание знает своего владельца (public Person owner). При наивной сериализации сохраняется ссылка на конкретный экземпляр объекта в памяти. После загрузки создаются совершенно новые экземпляры GameObject, и все старые ссылки указывают в никуда. Это гарантированный NullReferenceException и падение игры. 

### А как быть с динамическими объектами?

Агент (Person) ушел в здание, которого нет на сцене. При загрузке он появится в координатах (0,0,0) или исчезнет, потому что его GameObject был неактивен.
