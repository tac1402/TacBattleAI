---
title: ArchitectureSimplicity
---

## Как достигается легкость (простота) архитектуры
Главным критерием легкости архитектуры является возможность разбить монолитную архитектуру на минимально функциональные компоненты с минимальными зависимостями. И в последующем, как можно проще комбинировать различные компоненты между собой, не внося в свой проект крупную монолитную систему, а только то, что реально используется в проекте разработчика. В подавляющем большинстве случаев это достигается путем оверхейда, примером этому служит использование интерфейсов, ECS, MVC и тому подобные архитектурные надстройки. Все это свидетельство, лишь того, что текущие языки программирования с трудом дают удобные для этого механизмы. Но в C# для этого можно использовать т.н. partial class. Это позволяет включать компоненты исключительно путем физического копирования файлов, в которых определенны классы. 

Самый простой и часто используемый класс это класс [Item](TacStandart/Item.md). Item позволяет идентифицировать, группировать и различать сущности в вашем проекте. Но что делать, если вы реализуете компонент, который перемещает сущность по некоторым правилам? А другой компонент его вращает. При этом у вас есть проекты, где нужно только перемещение, где нужно только вращение, и проекты где нужно и то и другое. Вот правильный подход с нулевым оверхедом. Partial классы обеспечивают вам возможность просто копировать в проект нужные компоненты и не создавать оверхед архитектурные надстройки. Это удивительно просто.

```csharp
//TacItemMove.cs
namespace Tac.ItemMove
{
	public class ItemMove
	{
	    public void Move(BuildItem item, ... ) { ... }
	}
}
namespace Tac
{
	public partial class BuildItem : Item
	{
		public bool AllowMove = true;
	}
}
```
```csharp
//TacItemRotate.cs
namespace Tac.ItemRotate
{
	public class ItemRotate
	{
	    public void Rotate(BuildItem item, ... ) { ... }
	}
}
namespace Tac
{
	public partial class BuildItem : Item
	{
		public bool AllowRotate = true;
	}
}
```

Выше демонстрируется только идея использования partial. Настоящий пример см. состав класса [BuildItem](TacStandart/BuildItem.md), как он наполняется в зависимости от используемых компонентов. Так же учитывайте, что сами компоненты могут дополнять свою функциональность через исполоьзование partial. Например, см. в компоненте базовой камеры [TopCamera](TacCamera/TopCamera.md) и её расширение компонентом [TacItemMove](TacItemMove/TopCamera_.md). Таким образом, partial так же автоматически выполняет задачу встраивания, что называют [инъекцией/внедрением зависимостей](https://learn.microsoft.com/ru-ru/dotnet/core/extensions/dependency-injection), но без оверхеда. 

## Это не только одна ветвь наследования

Из-за упрощенных примеров, может сложится впечатление, что строится одна ветвь наследования Item наследуется от BuildItem, а все остальные наследуются дальше. Но это совсем не обязательно и не исключает агрегации. Рассмотрим боле сложный пример.

```csharp
namespace Tac.Agent
{
	public partial class Agent : Item
	{
	}
	public class AgentInPoint
	{
		public Agent Agent;
		public GameTime EnterTime;
	}
	public partial class AgentPoint : Item
	{
		public Queue<AgentInPoint> Agents = new Queue<AgentInPoint>();
	}
}
namespace Tac.Society
{
	public partial class Business : AgentPoint
	{
		public Agent Owner;
		public override void Init()
		{
			base.Init();
			Title = "Частный дом";
		}
	}
}
```
Здесь мы видим класс описывающий агента ([Agent](../../TacAgent/Agent)), который сам по себе самостоятелен, и может создаваться на сцене компонентом [ItemCreate](../../TacItemCreate/ItemCreate), посредством того ,что наследуется от [Item](../../TacStandart/Item). Другой класс точка в которой может быть агент ([AgentPoint](../../TacAgent/AgentPoint)), тоже самостоятельный объект, который может быть создан в сцене без агента. Но в процессе игры, мы будем отслеживать, какие агенты в него "заходили" и опосредственно через очередь _Queue<AgentInPoint> Agents_, агенты будут содержаться и будет протоколироваться время в этой точке. А уже на более высоком уровне точка-агента будет представлена как некий бизнес (_Business_), у которого кроме того есть _Owner_, который тоже агент, но не обязательно тот же самый. 

И теперь самое главное. Префабы в сцене юнити могут одновременно содержать несколько компонентов. В нашем случае, префаб "Маша Иванова", будет содержать компонент _Agent_. А префаб "Ламбард Васильева" будет содержать два компонента BuildItem, который позволит игроку разместить строение в сцене, и Business, который будет ответственен за специфику самого бизнес и описывать его структуру. Более высокоуровневые компоненты [ItemBuild](../../TacItemMove/ItemBuild) [_не путайте с BuildItem_] будут взаимодействовать с геймобъектом в сцене, через компонент _BuildItem_, а _Job_ будет отправлять "Машу Иванову" в "Ломбард Васильева" используя компонент _AgentPoint_.

Соответственно, код будет распределен в классах в соответствии с их ролями и ответственностями.



