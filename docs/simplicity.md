---
title: ArchitectureSimplicity
---

# Как достигается легкость (простота) архитектуры
Главным критерием легкости архитектуры является возможность разбить монолитную архитектуру на минимально функциональные компоненты с минимальными зависимостями. И в последующем, как можно проще комбинировать различные компоненты между собой, не внося в свой проект крупную монолитную систему, а только то, что реально используется в проекте разработчика. В подавляющем большинстве случаев это достигается путем оверхейда, примером этому служит использование интерфейсов, ECS, MVC и тому подобные архитектурные надстройки. Все это свидетельство, лишь того, что текущие языки программирования с трудом дают удобные для этого механизмы. Но в C# для этого можно использовать т.н. partial class. Это позволяет включать компоненты исключительно путем физического копирования файлов, в которых определенны классы. 

Самый простой и часто используемый класс это класс [Item](TacStandart/Item.md). Item позволяет идентифицировать, группировать и различать сущности в вашем проекте. Но что делать, если вы реализуете компонент, который перемещает сущность по некоторым правилам? А другой компонент его вращает. При этом у вас есть проекты, где нужно только перемещение, где нужно только вращение, и проекты где нужно и то и другое. Вот правильный подход с нулевым оверхедом. Partial классы обеспечивают вам возможность просто копировать в проект нужные компоненты и не создавать оверхед архитектурные надстройки. Это удивительно просто.

```csharp
//TacItemMove.cs
namespace Tac.ItemMove
{
	public class ItemMove
	{
	    public void Move(Item2 item, ... ) { ... }
	}
}
namespace Tac
{
	public partial class Item2 : Item
	{
		public bool AllowMove = true;
	}
}
```
```csharp
//TacItemRotate.cs
namespace Tac.ItemRotate
{
	public class ItemRotate
	{
	    public void Rotate(Item2 item, ... ) { ... }
	}
}
namespace Tac
{
	public partial class Item2 : Item
	{
		public bool AllowRotate = true;
	}
}
```
